<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Text Morph</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Courier New', monospace;
        }
        canvas {
            display: block;
        }
        .controls {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 11px;
            text-align: center;
        }
        input[type="range"] {
            width: 300px;
            height: 2px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            border-radius: 1px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            cursor: pointer;
            border-radius: 50%;
        }
        input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }
        .label {
            margin-top: 8px;
            opacity: 0.4;
            font-size: 10px;
            letter-spacing: 1px;
        }

    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="controls">
        <input type="range" id="morph">
        <div class="label">STABILITY</div>
    </div>
    <div id="mobile-message" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-family: 'SF Mono', 'Monaco', 'Courier New', monospace; font-size: 18px; text-align: center;">
        Mobile is not supported :(
    </div>

    <script>
        // Check if mobile and show message
        const isMobile = window.innerWidth <= 768;
        if (isMobile) {
            document.getElementById('mobile-message').style.display = 'block';
            document.querySelector('.controls').style.display = 'none';
            // Stop script execution for mobile
            throw new Error('Mobile not supported');
        }

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const morphSlider = document.getElementById('morph');

        let width = canvas.width = window.innerWidth;
        let height = canvas.height = window.innerHeight;

        // Responsive scaling based on screen size
        function getResponsiveScale() {
            const baseWidth = 1920; // Reference width
            return Math.min(width / baseWidth, 1.5); // Cap at 1.5x for very large screens
        }

        window.addEventListener('resize', () => {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            initText();
        });

        // ============================================
        // CONFIGURATION - Easy to adjust properties
        // ============================================
        const CONFIG = {
            // Slider settings (UI only - these are just display values)
            sliderMin: 0,           // Minimum slider value
            sliderMax: 100,         // Maximum slider value
            sliderStep: 1,          // Slider increment step
            sliderDefault: 0,       // Starting slider position (0-100)

            // Morph range settings (actual effect control)
            morphMin: 0.05,         // Minimum morph amount (0 = pure chaos, 1 = full text)
            morphMax: 0.5,          // Maximum morph amount (0 = pure chaos, 1 = full text)

            // Noise settings
            noiseRange: 0.5,        // Range of organic movement (Â±0.5 pixels)
            noiseSpeed: 0.02,       // How fast noise oscillates

            // Chaos mode settings
            chaosRandomness: 0.2,   // Random velocity change magnitude
            chaosDamping: 0.98,     // Velocity damping (0.98 = 2% slowdown)
            chaosMaxSpeed: 3,       // Maximum particle speed in chaos mode

            // Text morph settings
            springStrength: 0.02,   // How strongly particles pull toward text
            morphDamping: 0.95,     // Velocity damping in morph mode
            chaosBlendAmount: 0.3,  // How much chaos remains during morph

            // Auto-morph settings
            autoMorphSpeed: 0.0015, // Speed of automatic morphing

            // Particle settings
            particleCount: 2000,    // Number of particles
            baseParticleMinSize: 0.5,   // Minimum particle size (will scale responsively)
            baseParticleMaxSize: 2,     // Maximum particle size (will scale responsively)

            // Visual settings
            text: "STABILITY",      // Text to display
            baseTextSize: 180,      // Base font size in pixels (will scale responsively)
            textFont: "'SF Mono', 'Monaco', 'Courier New', monospace",    // Font family
            motionBlur: 0.15        // Motion blur amount (0-1)
        };

        // Get responsive text size
        function getTextSize() {
            const scale = getResponsiveScale();
            return CONFIG.baseTextSize * scale;
        }

        // Get responsive particle sizes
        function getParticleSizes() {
            const scale = getResponsiveScale();
            return {
                min: CONFIG.baseParticleMinSize * scale,
                max: CONFIG.baseParticleMaxSize * scale
            };
        }

        // Particle system
        const particles = [];
        // Calculate initial morphAmount from slider default
        const initialSliderNormalized = (CONFIG.sliderDefault - CONFIG.sliderMin) / (CONFIG.sliderMax - CONFIG.sliderMin);
        let morphAmount = CONFIG.morphMin + initialSliderNormalized * (CONFIG.morphMax - CONFIG.morphMin);
        let autoMorph = false;
        let morphDirection = 1;
        const TEXT = CONFIG.text;
        let particleOpacity = 0;
        const startTime = Date.now();
        
        // Text coordinates
        let textPoints = [];
        
        class Particle {
            constructor(initialMorph) {
                this.targetX = 0;
                this.targetY = 0;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;

                // Use responsive particle sizes
                const sizes = getParticleSizes();
                const sizeRange = sizes.max - sizes.min;
                this.size = Math.random() * sizeRange + sizes.min;
                this.noise = Math.random() * Math.PI * 2;

                // Initialize position based on morph amount
                // Will be set properly after targets are assigned
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.initialMorph = initialMorph;
                this.needsInit = true;
            }

            initPosition() {
                if (this.needsInit) {
                    // Blend between current random position and target based on initial morph
                    // this.x and this.y are already set to random positions in constructor
                    const randomX = this.x;
                    const randomY = this.y;
                    this.x = randomX + (this.targetX - randomX) * this.initialMorph;
                    this.y = randomY + (this.targetY - randomY) * this.initialMorph;
                    this.needsInit = false;
                }
            }

            update(morph) {
                // Organic noise-based movement
                this.noise += CONFIG.noiseSpeed;
                const noiseX = Math.cos(this.noise) * CONFIG.noiseRange;
                const noiseY = Math.sin(this.noise * 1.3) * CONFIG.noiseRange;

                if (morph < 0.01) {
                    // Pure chaos
                    this.vx += (Math.random() - 0.5) * CONFIG.chaosRandomness;
                    this.vy += (Math.random() - 0.5) * CONFIG.chaosRandomness;
                    this.vx *= CONFIG.chaosDamping;
                    this.vy *= CONFIG.chaosDamping;

                    const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
                    if (speed > CONFIG.chaosMaxSpeed) {
                        this.vx = (this.vx / speed) * CONFIG.chaosMaxSpeed;
                        this.vy = (this.vy / speed) * CONFIG.chaosMaxSpeed;
                    }

                    this.x += this.vx + noiseX;
                    this.y += this.vy + noiseY;
                } else {
                    // Blend between chaos and target
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;

                    // Spring force toward target
                    const springStrength = CONFIG.springStrength * morph;
                    this.vx += dx * springStrength;
                    this.vy += dy * springStrength;

                    // Add chaos influence (inverse to morph)
                    const chaosInfluence = (1 - morph) * CONFIG.chaosBlendAmount;
                    this.vx += (Math.random() - 0.5) * chaosInfluence;
                    this.vy += (Math.random() - 0.5) * chaosInfluence;

                    // Damping
                    this.vx *= CONFIG.morphDamping;
                    this.vy *= CONFIG.morphDamping;

                    this.x += this.vx + noiseX * (1 - morph);
                    this.y += this.vy + noiseY * (1 - morph);
                }

                // Wrap around edges in chaos mode
                if (morph < 0.5) {
                    if (this.x < 0) this.x = width;
                    if (this.x > width) this.x = 0;
                    if (this.y < 0) this.y = height;
                    if (this.y > height) this.y = 0;
                }
            }
            
            draw(morph, globalOpacity) {
                const alpha = (0.6 + morph * 0.4) * globalOpacity;
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function initText() {
            textPoints = [];

            // Create text with responsive size
            const fontSize = getTextSize();
            ctx.font = `bold ${fontSize}px ${CONFIG.textFont}`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = width;
            tempCanvas.height = height;

            tempCtx.font = `bold ${fontSize}px ${CONFIG.textFont}`;
            tempCtx.textAlign = 'center';
            tempCtx.textBaseline = 'middle';
            tempCtx.fillStyle = 'white';
            tempCtx.fillText(TEXT, width / 2, height / 2);
            
            const imageData = tempCtx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // Sample points from text (every 4th pixel for performance)
            const step = 4;
            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    const i = (y * width + x) * 4;
                    if (data[i + 3] > 128) {
                        textPoints.push({ x, y });
                    }
                }
            }
            
            // Shuffle for organic distribution
            textPoints.sort(() => Math.random() - 0.5);
            
            // Assign targets to particles
            particles.forEach((p, i) => {
                if (i < textPoints.length) {
                    p.targetX = textPoints[i].x;
                    p.targetY = textPoints[i].y;
                } else {
                    // Extra particles get random targets near text
                    const randomPoint = textPoints[Math.floor(Math.random() * textPoints.length)];
                    p.targetX = randomPoint.x + (Math.random() - 0.5) * 100;
                    p.targetY = randomPoint.y + (Math.random() - 0.5) * 100;
                }
                // Initialize particle position based on morphMin
                p.initPosition();
            });
        }
        
        // Initialize particles with the initial morph amount
        for (let i = 0; i < CONFIG.particleCount; i++) {
            particles.push(new Particle(morphAmount));
        }

        initText();

        // Initialize slider with CONFIG values
        morphSlider.min = CONFIG.sliderMin;
        morphSlider.max = CONFIG.sliderMax;
        morphSlider.step = CONFIG.sliderStep;
        morphSlider.value = CONFIG.sliderDefault;

        // Animation loop
        function animate() {
            ctx.fillStyle = `rgba(10, 10, 10, ${CONFIG.motionBlur})`;
            ctx.fillRect(0, 0, width, height);

            // Calculate fade in: invisible for 1s, then fade in over 1s
            const elapsed = Date.now() - startTime;
            if (elapsed < 1000) {
                particleOpacity = 0;
            } else {
                const fadeProgress = (elapsed - 1000) / 1000;
                particleOpacity = Math.min(1, fadeProgress);
            }

            particles.forEach(p => {
                p.update(morphAmount);
                p.draw(morphAmount, particleOpacity);
            });

            if (autoMorph) {
                morphAmount += CONFIG.autoMorphSpeed * morphDirection;
                if (morphAmount >= CONFIG.morphMax) {
                    morphAmount = CONFIG.morphMax;
                    morphDirection = -1;
                } else if (morphAmount <= CONFIG.morphMin) {
                    morphAmount = CONFIG.morphMin;
                    morphDirection = 1;
                }
                // Map morphAmount back to slider value
                const morphNormalized = (morphAmount - CONFIG.morphMin) / (CONFIG.morphMax - CONFIG.morphMin);
                morphSlider.value = morphNormalized * (CONFIG.sliderMax - CONFIG.sliderMin) + CONFIG.sliderMin;
            }

            requestAnimationFrame(animate);
        }
        
        // Controls
        morphSlider.addEventListener('input', (e) => {
            // Normalize slider value to 0-1, then map to morph range
            const sliderNormalized = (e.target.value - CONFIG.sliderMin) / (CONFIG.sliderMax - CONFIG.sliderMin);
            morphAmount = CONFIG.morphMin + sliderNormalized * (CONFIG.morphMax - CONFIG.morphMin);
            console.log('Slider value:', e.target.value, 'morphAmount:', morphAmount);
            autoMorph = false;
        });
        
        canvas.addEventListener('click', () => {
            autoMorph = !autoMorph;
        });

        animate();
    </script>
</body>
</html>