<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Moving Cluster Signaling</title>
  <style>
    html, body { margin:0; height:100%; background:#000; }
    canvas { display:block; width:100%; height:100%; image-rendering: pixelated; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
<script>
// === CONFIGURABLE PROPERTIES ===
const CONFIG = {
  syncSpeed: 0.1,          // How quickly agents synchronize (0-1)
  movementSpeed: 0.3,       // How fast agents move (0.1-3)
  syncedJitter: 0.1,        // Randomness for synced agents
  unsyncedJitter: 1,      // Randomness for unsynced agents
  upwardDrift: 0.05,        // Upward drift force for synced agents
  downwardDrift: 10,      // Downward drift force for unsynced agents
  driftNoise: 0.5,         // Noise added to drift forces
  
  // Color configuration
  syncedColor: { r: 200, g: 200, b: 200 },    // Synced agents color (RGB 0-255)
  unsyncedColor: { r: 25, g: 0, b: 255 },  // Unsynced agents color (RGB 0-255)
  unsyncedBrightness: 0.8,   // Brightness multiplier for unsynced agents (0-1)
  minSyncedBrightness: 0.15,   // Minimum brightness for synced agents (0-1)
  
  // Desktop settings
  desktop: {
    agentCount: 1000,         // Number of agents on desktop
    agentSize: 2,             // Size of each agent on desktop
    clusterRadius: 15         // How far agents can "see" each other on desktop
  },
  
  // Mobile settings
  mobile: {
    agentCount: 500,          // Number of agents on mobile (reduced for performance)
    agentSize: 4,             // Size of each agent on mobile (larger for visibility)
    clusterRadius: 25         // How far agents can "see" each other on mobile
  }
};

// Detect if device is mobile
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                 window.innerWidth <= 768 || 
                 ('ontouchstart' in window);

// Use mobile or desktop settings
const agentCount = isMobile ? CONFIG.mobile.agentCount : CONFIG.desktop.agentCount;
const agentSize = isMobile ? CONFIG.mobile.agentSize : CONFIG.desktop.agentSize;
const clusterRadius = isMobile ? CONFIG.mobile.clusterRadius : CONFIG.desktop.clusterRadius;

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const agents = [];
for (let i=0;i<agentCount;i++){
  agents.push({
    x:Math.random()*canvas.width,
    y:Math.random()*canvas.height,
    vx:(Math.random()-0.5)*1.2,
    vy:(Math.random()-0.5)*1.2,
    phase:Math.random()*Math.PI*2,
    speed:(0.01+Math.random()*0.02)
  });
}

function update(a, hasNeighbors){
  // random drift - more jitter when not synced
  const jitter = hasNeighbors ? CONFIG.syncedJitter : CONFIG.unsyncedJitter;
  a.vx += (Math.random()-0.5)*jitter;
  a.vy += (Math.random()-0.5)*jitter;
  
  // directional drift based on sync status
  if (hasNeighbors) {
    // synced agents drift upward with noise
    a.vy -= CONFIG.upwardDrift + (Math.random()-0.5)*CONFIG.driftNoise;
  } else {
    // unsynced agents drift downward with noise
    a.vy += CONFIG.downwardDrift + (Math.random()-0.5)*CONFIG.driftNoise;
  }
  
  // limit velocity based on movement speed
  const maxV = CONFIG.movementSpeed;
  a.vx=Math.max(-maxV,Math.min(maxV,a.vx));
  a.vy=Math.max(-maxV,Math.min(maxV,a.vy));
  a.x+=a.vx; a.y+=a.vy;
  // wrap around edges
  if(a.x<0) a.x=canvas.width;
  if(a.x>canvas.width) a.x=0;
  if(a.y<0) a.y=canvas.height;
  if(a.y>canvas.height) a.y=0;
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  for (let a of agents){
    // sync with neighbors
    let neighbors=0, avgPhase=0;
    for (let b of agents){
      let dx=a.x-b.x, dy=a.y-b.y;
      if (dx*dx+dy*dy < clusterRadius*clusterRadius && a!==b){
        neighbors++; avgPhase+=b.phase;
      }
    }
    if(neighbors>0){
      avgPhase/=neighbors;
      a.phase += (avgPhase - a.phase)*CONFIG.syncSpeed;

      // attraction to neighbors
      let fx = 0, fy = 0;
      for (let b of agents){
        let dx = b.x - a.x, dy = b.y - a.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < clusterRadius && dist > 0 && a !== b){
          let force = 0.01 / dist; // stronger attraction when closer
          fx += (dx / dist) * force;
          fy += (dy / dist) * force;
        }
      }
      a.vx += fx;
      a.vy += fy;
    }
    a.phase += a.speed;

    // update motion
    update(a, neighbors > 0);

    // Color based on sync status
    let r, g, b;
    if (neighbors > 0) {
      // Synced agents: pulsing color with minimum brightness
      const pulseBrightness = (Math.sin(a.phase)+1)/2; // 0 to 1
      const brightness = CONFIG.minSyncedBrightness + pulseBrightness * (1 - CONFIG.minSyncedBrightness);
      r = CONFIG.syncedColor.r * brightness;
      g = CONFIG.syncedColor.g * brightness;
      b = CONFIG.syncedColor.b * brightness;
    } else {
      // Unsynced agents: static dim color
      r = CONFIG.unsyncedColor.r * CONFIG.unsyncedBrightness;
      g = CONFIG.unsyncedColor.g * CONFIG.unsyncedBrightness;
      b = CONFIG.unsyncedColor.b * CONFIG.unsyncedBrightness;
    }
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(a.x, a.y, agentSize, agentSize);
  }
  requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>